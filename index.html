<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" type="text/css" href="doc.css" />
<title>Neo</title>
</head>

<body>
<h1>Neo</h1>
<address>The Facebook Database Engineering Team</address>
<address>Build on earlier work on leveldb by Sanjay Ghemawat
               (sanjay@google.com) and Jeff Dean (jeff@google.com)</address>

<p>
<code>Neo</code> javascript machine learning library developed on AgentSmith. 
<p>
<h1>Neo.Cluster.Kmeans(n_clusters, init, n_jobs, maxiter, tol)</h1>
<p>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>n_clusters</b> : int, default 8, number of clusters
      <p><b>init</b> : string, default "kmeans++", algorithm of initialization of clusters. 
      <small>*<b>init</b> should be "kmeans++" or "random".</small>
      <p><b>n_jobs</b> : int, default 1. the number of process when calculating k-means.
	<small>*<b>n_jobs</b> > 1 is not implemented now.</small>
      <p><b>maxiter</b> : int, default 300, max iteration of Expectation and Maximization step of EM algorithm. 
      <p><b>tol</b> : float, default 0.001, convergence criterion. 
    </td>
  </tr>
</table>
<h2>fit(X)</h2>
<p>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>X</b> : array [n_samples, n_feature], data matrix used for trainig gmm. Each row corresponds to a single data point.
    </td>
  </tr>
  <tr>
    <td class="title">
      <dt>returns:</dt>
    </td>
    <td class="data">
      <p><b>this</b> : instance of GMM, which has fitted parameters.
    </td>
  </tr>
</table>
<p>
<h1>Neo.Mixture.GMM(n_components, n_iter, thresh, min_covar)</h1>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>n_components</b> : int, default 1, the number of component of gmm
      <p><b>n_iter</b> : int, default 100, max iteration of Expectation and Maximization step of EM algorithm. 
      <p><b>thresh</b> : float, default 0.01, convergence criterion. 
      <p><b>min_covar</b> : float, default 0.01, floor on the diagonal of the covariance matrix to prevent overfitting
    </td>
  </tr>
</table>
<p>
<h2>fit(X)</h2>
<p>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>X</b> : array [n_samples, n_feature], data matrix used for trainig gmm. Each row corresponds to a single data point.
    </td>
  </tr>
  <tr>
    <td class="title">
      <dt>returns:</dt>
    </td>
    <td class="data">
      <p><b>this</b> : instance of GMM, which has fitted parameters.
    </td>
  </tr>
</table>
<h2>calcLogLikelihood(X)</h2>
<p>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>X</b> : array [n_samples, n_feature], data matrix.
    </td>
  </tr>
  <tr>
    <td class="title">
      <dt>returns:</dt>
    </td>
    <td class="data">
      <p><b>loglikelihood</b> : float, sum of negative log likelihood of given data X.
    </td>
  </tr>
</table>
<h2>showParams()</h2>
<p>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b></b> : None
    </td>
  </tr>
  <tr>
    <td class="title">
      <dt>returns:</dt>
    </td>
    <td class="data">
      <p><b></b> : None
    </td>
  </tr>
</table>
<p>
<h1>Neo.Decomposition.PCA(n_components, whiten)</h1>
<p>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>n_components</b> : int, default 1, the number of dimension after reduction
      <p><b>whiten</b> : boolean, default false, whether whitening is applied or not
    </td>
  </tr>
</table>
<h2>fit(X)</h2>
<p>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>X</b> : array [n_samples, n_feature], data matrix that dimension reduction is applied. Each row corresponds to a single data point.
    </td>
  </tr>
  <tr>
    <td class="title">
      <dt>returns:</dt>
    </td>
    <td class="data">
      <p><b>this</b> : instance of PCA, which has fitted parameters.
    </td>
  </tr>
</table>
<p>
<h1>Neo.CrossDecomposition.CCA(n_components, scale)</h1>
<p>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>n_components</b> : int, default 2, the number of dimension of latent space.
      <p><b>normalize</b> : boolean, default true, whether data is centerized and normalized or not
    </td>
  </tr>
</table>
<p>
<p>
<h2>fit(X,Y)</h2>
<p>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>X</b> : array [n_samples, n_features], training samples of domain 1 
      <p><b>Y</b> : array [n_samples, n_features], training samples of domain 2
      <small><p>*the number of samples of X and Y should be the same.</small>
    </td>
  </tr>
  <tr>
    <td class="title">
      <dt>returns:</dt>
    </td>
    <td class="data">
      <p><b>this</b> : instance of CCA, which has fitted parameters.
    </td>
  </tr>
</table>
<h2>transform(X,Y)</h2>
<p>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>X</b> : array [n_samples, n_features], test samples of domain 1
      <p><b>Y</b> : array [n_samples, n_features], test samples of domain 2.
      <small><p>*the number of samples of X and Y should be the same.</small>
    </td>
  </tr>
  <tr>
    <td class="title">
      <dt>returns:</dt>
    </td>
    <td class="data">
      <p><b>X_score</b> : array [n_samples, n_components], samples of domain1 after projection onto latent space.
      <p><b>Y_score</b> : array [n_samples, n_components], samples of domain2 after projection onto latent space.
    </td>
  </tr>
</table>
<p>
<h1>Neo.Neighbors.KNeighborsClassifier(n_neighbors, algorithm, lear_size, weights)</h1>
<p>
<p>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>n_neightbors</b> : int, default 5, the number of neighbors used to classify
      <p><b>algorithm</b> : string, default "auto", algorithm of kNN
      <p><b>leaf_size</b> : int, default 30, size of leaf
      <p><b>weights</b> : string, default "uniform", weight of neighbors for prediction
      <p><small>*<b>weights</b> should be "uniform" or "dist".</small>
    </td>
  </tr>
</table>
<h2>fit(X, y)</h2>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>X</b> : array [n_samples, n_feature], training data matrix. each row corresponds to a single data point. 
      <p><b>y</b> : array [n_samples, 1], target vector. i-th element corresponds to the target value of i-th data of X.  
    </td>
  </tr>
  <tr>
    <td class="title">
      <dt>returns:</dt>
    </td>
    <td class="data">
      <p><b>this</b> : instance of kNN Classifier, which has fitted parameters.
    </td>
  </tr>
</table>

<h2>predict(X)</h2>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>X</b> : array [n_samples, n_feature], data matrix usef for prediction.
    </td>
  </tr>
  <tr>
    <td class="title">
      <dt>returns:</dt>
    </td>
    <td class="data">
      <p><b>res</b> : array [n_samples, n_class], (i, j) element corresponds to predicted value of i-th sample to j-th class.
    </td>
  </tr>
</table>
<p>
<p>
<h1>Neo.LinearModel.LinearRegression(center, normalize, solver)</h1>
<p>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>center</b> : boolean, default true, whether data is centerized or not
      <p><b>normalize</b> : boolean, default true, whether data is normalized or not
      <p><b>solver</b> : string, default 'qr', solver used to calculate parameter
      <p><small>*<b>solver</b> should be "lrqr" or "qr".</small>
    </td>
  </tr>
</table>
<h2>fit(X, y)</h2>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>X</b> : array [n_samples, n_feature], data matrix for training. each row corresponds to a single data point. 
      <p><b>y</b> : array [n_samples, 1], target vector. i-th element corresponds to the target value of i-th data of X.  
    </td>
  </tr>
  <tr>
    <td class="title">
      <dt>returns:</dt>
    </td>
    <td class="data">
      <p><b>this</b> : instance of Ridge Regression, which has fitted parameters.
    </td>
  </tr>
</table>
<p>
<h2>predict(X)</h2>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>X</b> : array [n_samples, n_feature], data matrix used for prediction.
    </td>
  </tr>
  <tr>
    <td class="title">
      <dt>returns:</dt>
    </td>
    <td class="data">
      <p><b>pred</b> : array [n_samples, 1], i-th element corresponds to the target value of i-th data of test data.  
    </td>
  </tr>
</table>
<p>
<h1>Neo.LinearModel.Lasso(lambda, center, normalize, n_iter, tolerance)</h1>
<p>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>lambda</b> : float, default 1.0, constant value for avoiding overfit
      <p><b>center</b> : boolean, default true, whether data is centerized or not
      <p><b>normalize</b> : boolean, default true, whether data is normalized or not
      <p><b>n_iter</b> : int, default 1000, the number of iteration
      <p><b>tolerance</b> : int, default 0.0001, convergence criterion of cooridate decent.
    </td>
  </tr>
</table>
<h2>fit(X, y)</h2>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>X</b> : array [n_samples, n_feature], data matrix for training. each row corresponds to a single data point. 
      <p><b>y</b> : array [n_samples, 1], target vector. i-th element corresponds to the target value of i-th data of X.  
    </td>
  </tr>
  <tr>
    <td class="title">
      <dt>returns:</dt>
    </td>
    <td class="data">
      <p><b>this</b> : instance of Ridge Regression, which has fitted parameters.
    </td>
  </tr>
</table>
<p>
<h2>predict(X)</h2>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>X</b> : array [n_samples, n_feature], data matrix used for prediction.
    </td>
  </tr>
  <tr>
    <td class="title">
      <dt>returns:</dt>
    </td>
    <td class="data">
      <p><b>pred</b> : array [n_samples, 1], i-th element corresponds to the target value of i-th data of test data.  
    </td>
  </tr>
</table>
<p>
<h1>Neo.LinearModel.Ridge(lambda, center, nermalize, solver, n_iter, tolerance)</h1>
<p>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>lambda</b> : float, default 1.0, constant value for avoiding overfit
      <p><b>center</b> : boolean, default true, whether data is centerized or not
      <p><b>normalize</b> : boolean, default true, whether data is normalized or not
      <p><b>solver</b> : string, default 'cd', solver used to calculate parameter
      <p><small>*<b>solver</b> should be "lrqr" or "cd"(coordinate decent).</small>
      <p><b>n_iter</b> : int, default 1000, the number of iteration
      <p><b>tolerance</b> : int, default 0.0001, convergence criterion of cooridate decent.
    </td>
  </tr>
</table>
<p>
<h2>fit(X, y)</h2>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>X</b> : array [n_samples, n_feature], data matrix for training. each row corresponds to a single data point. 
      <p><b>y</b> : array [n_samples, 1], target vector. i-th element corresponds to the target value of i-th data of X.  
    </td>
  </tr>
  <tr>
    <td class="title">
      <dt>returns:</dt>
    </td>
    <td class="data">
      <p><b>this</b> : instance of Ridge Regression, which has fitted parameters.
    </td>
  </tr>
</table>
<p>
<h2>predict(X)</h2>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>X</b> : array [n_samples, n_feature], data matrix used for prediction.
    </td>
  </tr>
  <tr>
    <td class="title">
      <dt>returns:</dt>
    </td>
    <td class="data">
      <p><b>pred</b> : array [n_samples, 1], i-th element corresponds to the target value of i-th data of test data.  
    </td>
  </tr>
</table>

<h1>Neo.LinearModel.Logistic(eta, alpha, center, n_iter)</h1>
<p>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>eta</b> : float, default 0.01, learning ratio for delta Error
      <p><b>alpha</b> : float, default 0.015, l2-regularization strength
      <p><b>center</b> : boolean, default true, whether data is centerized or not
	<small>*<b>center</b> is not implemented.</small>
      <p><b>n_iter</b> : int, default 100, the number of iteration
    </td>
  </tr>
</table>
<h2>fit(X, y)</h2>
<p>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>X</b> : array [n_samples, n_feature], data matrix for training. each row corresponds to a single data point. 
      <p><b>y</b> : array [n_samples, 1], target vector. i-th element corresponds to the target value of i-th data of X.  
    </td>
  </tr>
  <tr>
    <td class="title">
      <dt>returns:</dt>
    </td>
    <td class="data">
      <p><b>this</b> : instance of Logistic Regression, which has fitted parameters.
    </td>
  </tr>
</table>
<p>
<h2>predict(X)</h2>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>X</b> : array [n_samples, n_feature], data matrix used for prediction.
    </td>
  </tr>
  <tr>
    <td class="title">
      <dt>returns:</dt>
    </td>
    <td class="data">
      <p><b>pred</b> : array [n_samples, 1], i-th element corresponds to the target value of i-th data of test data.  
    </td>
  </tr>
</table>
<p>
<h1>Neo.LinearModel.Perceptron(eta, center, n_iter)</h1>
<p>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>eta</b> : float, default 1.0, learning ratio 
      <p><b>center</b> : boolean, default true, whether data is centerized or not
      <p><b>n_iter</b> : int, default 100, the number of iteration
    </td>
  </tr>
</table>

<h2>fit(X, y)</h2>
<p>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>X</b> : array [n_samples, n_feature], data matrix of training samples. Each row corresponds to a single data point.
      <p><b>y</b> : array [n_samples, 1], label vector of training samples. i-th element corresponds to the target value of i-th data of X. 
    </td>
  </tr>
  <tr>
    <td class="title">
      <dt>returns:</dt>
    </td>
    <td class="data">
      <p><b>this</b> : instance of Perceptron, which has fitted parameters.
    </td>
  </tr>
</table>
<p>
  <h2>predict(X)</h2>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>X</b> : array [n_samples, n_feature], data matrix used for prediction.
    </td>
  </tr>
  <tr>
    <td class="title">
      <dt>returns:</dt>
    </td>
    <td class="data">
      <p><b>pred</b> : array [n_samples, 1], i-th element corresponds to the target value of i-th data of test data.  
    </td>
  </tr>
</table>

<p>
<h1>Neo.LinearModel.SGDRegressor(algorithm, n_iter, t_zero, aver)</h1>
<p>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>algorithm</b> : string, default 'sgdsvm', algorithm for online training
      <p><small>*<b>algorithm</b> should be "sgdsvm" or "perceptron".</small>
      <p><b>n_iter</b> : int, default 1000, the number of iteration
      <p><b>t_zero</b> : float, default 1.0, value to decide step size alpha   
      <p><b>aver</b> : boolean, default true, whether averaging is used or not
    </td>
  </tr>
</table>

<h2>fit(X, y, init_w)</h2>
<p>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>X</b> : array [n_samples, n_feature], data matrix of training samples. Each row corresponds to a single data point.
      <p><b>y</b> : array [n_samples, n_class], label matrix of training samples. Each row corresponds to label information of single data.
      <p><b>init_w</b> : array [n_feature+1, n_class], initial value of weight parameter
    </td>
  </tr>
  <tr>
    <td class="title">
      <dt>returns:</dt>
    </td>
    <td class="data">
      <p><b>this</b> : instance of Regressor, which has fitted parameters.
    </td>
  </tr>
</table>
<p>
  <h2>predict(X)</h2>
<table class="datatable">
  <tr>
    <td class="title">
      <dt>parameters:</dt>
    </td>
    <td class="data">
      <p><b>X</b> : array [n_samples, n_feature], data matrix used for prediction.
    </td>
  </tr>
  <tr>
    <td class="title">
      <dt>returns:</dt>
    </td>
    <td class="data">
      <p><b>pred</b> : array [n_samples, 1], i-th element corresponds to the target value of i-th data of test data.  
    </td>
  </tr>
</table>

<p>
<p>
<a href="https://github.com/facebook/rocksdb/wiki/Merge-Operator">
    Merge Operator</a>
<p>
<a href="https://github.com/facebook/rocksdb/wiki/Merge-Operator-Implementation">
    Merge Operator Implementation</a>

<p>


</body>
</html>

